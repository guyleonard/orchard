#!/usr/bin/env perl
use strict;
use warnings;

use Bio::SeqIO;
use Bio::Tree::Draw::Cladogram;
use Bio::TreeIO;
use DBI;
use File::Basename;
use File::Path qw(make_path);
use Getopt::Long;
use IO::Tee;
use YAML::XS qw/LoadFile/;

our $VERSION = 0.1;
my $version = "Orchard Pipeline v1.0 -- orchard_accessories v$VERSION\n";

#
# Other Variables
#
my $params_file;
my ( $outdir, $threads );
my ( $orchardDB_location, $orchardDB_username, $orchardDB_password );
my $log;
my ($rename_sequences, $rename_alignments, $rename_masks,
    $rename_excluded,  $rename_newick_trees
);
my ( $renamed, $eps_tree, $svg_tree, $pdf_tree );

#
# getopt Logic
#
if ( !@ARGV ) {
    help_message();
}

GetOptions(
    'paramaters|params|p=s' => \$params_file,
    'seqs|s'                => \$rename_sequences,
    'align|a'               => \$rename_alignments,
    'mask|m'                => \$rename_masks,
    'excluded|e'            => \$rename_excluded,
    'newick|n'              => \$rename_newick_trees,
    'renamed'               => \$renamed,
    'eps_tree'              => \$eps_tree,
    'svg_tree'              => \$svg_tree,
    'pdf_tree'              => \$pdf_tree,
    'version|v'             => sub { print "$version"; exit(0) },
    'help|h' => sub { help_message() }
) or help_message();

#
# Main
#
if ( -f $params_file ) {
    my $paramaters = LoadFile("$params_file");

    $outdir  = $paramaters->{user}->{results};
    $threads = $paramaters->{user}->{threads};

    $orchardDB_location = $paramaters->{directories}->{orchardDB};
    $orchardDB_username = $paramaters->{database}->{username};
    $orchardDB_password = $paramaters->{database}->{password};

    my $logfile = ">>$outdir\_orchard_accessories.log";
    $log = IO::Tee->new( \*STDOUT, $logfile );
    select $log;

    if ( defined $rename_sequences eq 1 ) {
        rename_sequences('seqs');
    }

    if ( defined $rename_alignments eq 1 ) {
        rename_sequences('alignments');
    }

    if ( defined $rename_masks eq 1 ) {
        rename_sequences('masking');
    }

    if ( defined $rename_excluded eq 1 ) {
        rename_sequences('excluded');
    }

    if ( defined $rename_newick_trees eq 1 ) {
        rename_newick_trees();
    }

    if ( defined $eps_tree eq 1 && !defined $renamed ) {
        draw_eps_tree('');
    }
    elsif ( defined $eps_tree eq 1 && defined $renamed eq 1 ) {
        draw_eps_tree('renamed');
    }

    if ( defined $svg_tree eq 1 && !defined $renamed ) {
        draw_dendroscope_tree( '', 'svg' );
    }
    elsif ( defined $svg_tree eq 1 && defined $renamed eq 1 ) {
        draw_dendroscope_tree( 'renamed', 'svg' );
    }

    if ( defined $pdf_tree eq 1 && !defined $renamed ) {
        draw_dendroscope_tree( '', 'pdf' );
    }
    elsif ( defined $pdf_tree eq 1 && defined $renamed eq 1 ) {
        draw_dendroscope_tree( 'renamed', 'pdf' );
    }
}
else {
    print
        "[orchard_accessories:ERRR] - The parameters file $params_file does not exist!\n";
    exit(1);
}

#
# Trees
#
sub draw_eps_tree {
    my $renamed         = shift;
    my $trees_directory = "$outdir\/trees\/$renamed";
    my $trees_dir_out   = "$trees_directory\/eps";
    make_path("$trees_dir_out");

    my @trees_to_svg = glob "$trees_directory\/*.treefile";

    for my $i ( 0 .. $#trees_to_svg ) {
        my $current_file = $trees_to_svg[$i];

        print
            "[orchard_accessories:INFO] - Drawing EPS $renamed Tree from $current_file\n";

        my $basename = fileparse( $current_file, qr/\Q.treefile\E/ );

        my $tree_input = Bio::TreeIO->new(
            -file   => "$current_file",
            -format => 'newick'
        );

        if ( my $tree = $tree_input->next_tree ) {
            my $tree_output = Bio::Tree::Draw::Cladogram->new(
                -bootstrap => 1,
                -tree      => $tree,
                -compact   => 0
            );
            $tree_output->print( -file => "$trees_dir_out\/$basename.eps" );
        }
    }
}

sub draw_dendroscope_tree {
    my ( $renamed, $type ) = @_;
    my $trees_directory = "$outdir\/trees\/$renamed";

    my $trees_dir_out = "$trees_directory\/$type";
    make_path("$trees_dir_out");

    my @trees_to_svg = glob "$trees_directory\/*.treefile";

    for my $i ( 0 .. $#trees_to_svg ) {
        my $current_file = $trees_to_svg[$i];

        print
            "[orchard_accessories:INFO] - Drawing $type $renamed Tree from $current_file\n";

        my $basename = fileparse( $current_file, qr/\Q.treefile\E/ );

        #$basename =~ m/([0-9a-f]{32})\_.*/i;
        $basename =~ m/(.*)(_hits_aligned_masked_)(FT|IQ)/i;
        my $accession = $1;

        if ( $renamed eq "renamed" ) {
            my $dbh = sqllite();

            my $statement
                = qq(SELECT odb_accessions.extracted_accession, odb_maintable.genus_species, odb_maintable.source FROM odb_maintable INNER JOIN odb_accessions ON odb_maintable.genome_id = odb_accessions.lookup_id WHERE hashed_accession='$accession');
            my $prepare = $dbh->prepare($statement);
            $prepare->execute();

            my ( $extracted_accession, $genus_species, $source )
                = $prepare->fetchrow_array();
        }

        my $dendroscope_opts = "open file=$current_file\;\n";
        $dendroscope_opts
            .= "set drawer=RectangularPhylogram\;\nladderize=left\;\n";
        $dendroscope_opts .= "zoom what=expand\;\nset sparselabels=false\;\n";
        $dendroscope_opts
            .= "select nodes=labeled\;\nset labelcolor=255 0 0\;\n";
        $dendroscope_opts
            .= "deselect all\;\nselect nodes=leaves\;\nset labelcolor=0 0 0\;\ndeselect all\;\n";
        $dendroscope_opts
            .= "find searchtext=$accession\;\nset labelfillcolor=255 0 0\;\ndeselect all\;\n";
        $dendroscope_opts
            .= "exportimage file=$trees_dir_out\/$basename\.$type format=$type replace=true\;\n";
        $dendroscope_opts .= "quit\;\n";

        open my $command_file, '>', "$outdir\/dendroscope.cmd";
        print {$command_file} $dendroscope_opts;
        close $command_file;

        my $dendroscope_command
            = "xvfb-run --auto-servernum --server-num=1 Dendroscope -g true -c $outdir\/dendroscope.cmd 1>/dev/null";
        system($dendroscope_command);

        unlink "$outdir\/dendroscope.cmd";
    }
}

#
# Renaming
#
sub rename_sequences {
    my $stage             = shift;
    my $directory         = "$outdir\/$stage";
    my $renamed_directory = "$directory\/renamed";
    make_path($renamed_directory);

    my $dbh = sqllite();

    my @files_to_rename = glob "$directory\/*.fasta";

    for my $i ( 0 .. $#files_to_rename ) {
        my $current_file = $files_to_rename[$i];
        print
            "[orchard_accessories:INFO] - Renaming Taxa in Sequence File $current_file\n";

        my $input_file = new Bio::SeqIO(
            -file   => "$current_file",
            -format => "fasta"
        );

        my $basename = fileparse( $current_file, qr/\Q.fasta\E/ );
        my $output_file = new Bio::SeqIO(
            -file   => ">$renamed_directory\/$basename\_renamed\.fasta",
            -format => "fasta"
        );

        while ( my $seq = $input_file->next_seq ) {

            my $current_seq = $seq->id;

            my $statement
                = qq(SELECT odb_accessions.extracted_accession, odb_maintable.genus_species, odb_maintable.source FROM odb_maintable INNER JOIN odb_accessions ON odb_maintable.genome_id = odb_accessions.lookup_id WHERE hashed_accession='$current_seq');
            my $prepare = $dbh->prepare($statement);
            $prepare->execute();

            my ( $extracted_accession, $genus_species, $source )
                = $prepare->fetchrow_array();

            if ( defined $genus_species ) {
                $genus_species =~ s/ /\_/g;

                $seq->id("$genus_species\_\[$source\-$extracted_accession\]");
            }

            $output_file->write_seq($seq);
        }
    }
}

sub rename_newick_trees {
    my $trees_directory         = "$outdir\/trees";
    my $trees_renamed_directory = "$outdir\/trees\/renamed";
    make_path($trees_renamed_directory);

    my $dbh = sqllite();

    my @trees_to_rename = glob "$trees_directory\/*.treefile";

    for my $i ( 0 .. $#trees_to_rename ) {
        my $current_file = $trees_to_rename[$i];
        print
            "[orchard_accessories:INFO] - Renaming Taxa in Tree $current_file\n";

        my $input_tree = new Bio::TreeIO(
            -file   => "$current_file",
            -format => "newick"
        );

        my $basename = fileparse( $current_file, qr/\Q.treefile\E/ );
        my $output_tree = new Bio::TreeIO(
            -file =>
                ">$trees_renamed_directory\/$basename\_renamed\.treefile",
            -format => "newick"
        );

        while ( my $tree = $input_tree->next_tree ) {
            my $rootnode = $tree->get_root_node;

            foreach my $node ( $rootnode->get_all_Descendents() ) {
                if ( $node->is_Leaf ) {
                    my $current_node = $node->id;

                    my $statement
                        = qq(SELECT odb_accessions.extracted_accession, odb_maintable.genus_species, odb_maintable.source FROM odb_maintable INNER JOIN odb_accessions ON odb_maintable.genome_id = odb_accessions.lookup_id WHERE hashed_accession='$current_node');
                    my $prepare = $dbh->prepare($statement);
                    $prepare->execute();

                    my ( $extracted_accession, $genus_species, $source )
                        = $prepare->fetchrow_array();

                    if ( defined $genus_species ) {
                        $node->id(
                            "$genus_species \[$source\-$extracted_accession\]"
                        );
                    }
                }
            }

            $output_tree->write_tree($tree);
        }
    }
}

#
# SQLLite
#
sub sqllite {
    my $db_name  = fileparse $orchardDB_location;
    my $driver   = 'SQLite';
    my $database = "$orchardDB_location\/$db_name\.sqlite";
    my $dsn      = "DBI:$driver:dbname=$database";

    my $dbh
        = DBI->connect( $dsn, $orchardDB_username, $orchardDB_password,
        { RaiseError => 1 } )
        or die $DBI::errstr;

    return $dbh;
}

#
# Help Function
#
sub help_message {
    print "Usage: orchard_accessories -p params.yaml -n\n";
    print "Required Parameters\n";
    print "\t-p <parameters.yaml>\n";
    print "Optional Parameters\n";
    print "Renaming\n";
    print "\t-s\tRename Taxa in Sequence Hits Files\n";
    print "\t-a\tRename Taxa in Alignment Files\n";
    print "\t-m\tRename Taxa in Masked Files\n";
    print "\t-e\tRename Taxa in Excluded Files\n";
    print "\t-n\tRename Taxa in Newick Trees\n";
    print "Tree Drawing\n";
    print "\t-renamed\tConvert Renamed Trees use with below\n";
    print "\t-eps_tree\tDraw a Phylogram in EPS Format (Basic)\n";
    print "\t-svg_tree\tDraw a Phylogram with Dendroscope in SVG Format\n";
    print "\t-pdf_tree\tDraw a Phylogram with Dendroscope in PDF Format\n";
    print
        "Cite: https://github.com/guyleonard/orchard and doi: 10.1105/tpc.109.065805\n";
    exit(0);
}
