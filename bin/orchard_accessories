#!/usr/bin/env perl
use strict;
use warnings;

use Bio::SeqIO;
use Bio::Tree::Draw::Cladogram;
use Bio::TreeIO;
use DBI;
use File::Basename;
use File::Path qw(make_path);
use Getopt::Long;
use IO::Tee;
use YAML::XS qw/LoadFile/;
use XML::Tidy;

use Data::Dumper;

our $VERSION = 0.1;
my $version = "Orchard Pipeline v1.0 -- orchard_accessories v$VERSION\n";

#
# Other Variables
#
my $params_file;
my ( $outdir, $threads );
my ( $orchardDB_location, $orchardDB_username, $orchardDB_password );
my $log;
my ($rename_sequences, $rename_alignments, $rename_masks,
    $rename_excluded,  $rename_newick_trees
);
my ( $renamed, $eps_tree, $svg_tree, $pdf_tree );
my ( $colourise, @taxonomy_list, %taxonomy_colours );

#
# getopt Logic
#
if ( !@ARGV ) {
    help_message();
}

GetOptions(
    'paramaters|params|p=s' => \$params_file,
    'seqs|s'                => \$rename_sequences,
    'align|a'               => \$rename_alignments,
    'mask|m'                => \$rename_masks,
    'excluded|e'            => \$rename_excluded,
    'newick|n'              => \$rename_newick_trees,
    'renamed'               => \$renamed,
    'eps_tree'              => \$eps_tree,
    'svg_tree'              => \$svg_tree,
    'pdf_tree'              => \$pdf_tree,
    'colourise|c'           => \$colourise,
    'version|v'             => sub { print "$version"; exit(0) },
    'help|h' => sub { help_message() }
) or help_message();

#
# Main
#
if ( -f $params_file ) {
    my $paramaters = LoadFile("$params_file");

    $outdir  = $paramaters->{user}->{results};
    $threads = $paramaters->{user}->{threads};

    $orchardDB_location = $paramaters->{directories}->{orchardDB};
    $orchardDB_username = $paramaters->{database}->{username};
    $orchardDB_password = $paramaters->{database}->{password};

    my $logfile = ">>$outdir\_orchard_accessories.log";
    $log = IO::Tee->new( \*STDOUT, $logfile );
    select $log;

    if ( defined $rename_sequences eq 1 ) {
        rename_sequences('seqs');
    }

    if ( defined $rename_alignments eq 1 ) {
        rename_sequences('alignments');
    }

    if ( defined $rename_masks eq 1 ) {
        rename_sequences('masking');
    }

    if ( defined $rename_excluded eq 1 ) {
        rename_sequences('excluded');
    }

    if ( defined $rename_newick_trees eq 1 ) {
        rename_newick_trees();
    }

    if ( defined $eps_tree eq 1 && !defined $renamed ) {
        draw_eps_tree('');
    }
    elsif ( defined $eps_tree eq 1 && defined $renamed eq 1 ) {
        draw_eps_tree('renamed');
    }

    if ( defined $svg_tree eq 1 && !defined $renamed ) {
        draw_dendroscope_tree( '', 'svg' );
    }
    elsif ( defined $svg_tree eq 1 && defined $renamed eq 1 ) {
        draw_dendroscope_tree( 'renamed', 'svg' );
    }

    if ( defined $pdf_tree eq 1 && !defined $renamed ) {
        draw_dendroscope_tree( '', 'pdf' );
    }
    elsif ( defined $pdf_tree eq 1 && defined $renamed eq 1 ) {
        draw_dendroscope_tree( 'renamed', 'pdf' );
    }

    if ( defined $colourise eq 1 ) {
        if ( defined $paramaters->{annotation}->{taxonomy_colours} ) {
            @taxonomy_list = split /,/,
                $paramaters->{annotation}->{taxonomy_colours};

            %taxonomy_colours
                = map { my ( $key, $value ) = split ";"; $key => $value }
                @taxonomy_list;

            colourise_svg_trees( 'renamed', 'svg', %taxonomy_colours );
        }
        else {
            print
                "[orchard_accessories:ERRR] - No colours for taxonomic groups in paramaters file.\n";
        }
    }
}
else {
    print
        "[orchard_accessories:ERRR] - The parameters file $params_file does not exist!\n";
    exit(1);
}

#
# Annotation
#
sub colourise_svg_trees {
    my ( $renamed, $type, %taxonomy_colours ) = @_;
    my $trees_directory = "$outdir\/trees\/$renamed\/$type";

    my $colourised_dir_out = "$trees_directory\/colourised";
    make_path("$colourised_dir_out");

    my $colour = "black";
    my $width  = 0;
    my $height = 0;

    my $dbh = sqllite();

    my @trees = glob "$trees_directory\/*.svg";

    for my $i ( 0 .. $#trees ) {
        my $current_file = $trees[$i];

        print "[orchard_accessories:INFO] - Colourising $current_file\n";
        open my $svg_in, '<', "$current_file";

        my $basename = fileparse( $current_file, qr/\Q.svg\E/ );
        open my $svg_out, '>',
            "$colourised_dir_out\/$basename\_colourised\.svg";

        while ( my $line = <$svg_in> ) {
            if ( $line
                =~ m/\s+<rect width=\"(\d+)\"\s+x=\"\d+\"\s+height=\"(\d+)\".*/
                )
            {
                $width  = $1;
                $height = $2;
                print $svg_out "$line";
            }
            elsif ( $line
                =~ m/\s+<rect height=\"(\d+)\"\s+stroke=\"none\"\s+width=\"(\d+)\".*/
                )
            {
                $width  = $2;
                $height = $1;
                print $svg_out "$line";
            }
            # <text stroke="none" x="754" xml:space="preserve" y="256">Zea mays [Ensembl-Zm00001d049188_P008]</text>
            elsif ( $line =~ m/(\s+\<text xml\:space\=\"preserve\")/is || $line =~ m/(\s+\<text stroke=\"none\")/is ) {
                my $taxon_name = $line;

                if ( $taxon_name
                    =~ m/(.*\>)(.*?)(\s+)(\[.*\])(\<\/text\>)/isgm )
                {
                    $taxon_name = $2;

                    my $statement
                        = qq(SELECT odb_maintable.taxonomy FROM odb_maintable WHERE genus_species='$taxon_name');
                    my $prepare = $dbh->prepare($statement);
                    $prepare->execute();

                    my $taxonomy = $prepare->fetchrow_array();

                    foreach ( keys %taxonomy_colours ) {
                        if ( $taxonomy =~ /$_/i ) {
                            $colour = "$taxonomy_colours{$_}";
                        }
                    }

                    $line =~ s/\<text /\<text fill\=\"$colour\" /;
                    print $svg_out "$line";
                }
                else {
                    $line
                        =~ s/\<text /\<text fill\=\"black\" font-weight\=\"bold\" /;
                    print $svg_out "$line";
                }
            }
            elsif ( $line =~ m/\<\/svg\>/ ) {

                print "KEY\n";

                $line =~ s/\<\\svg\>//;

                draw_key( $svg_out, "$width", "$height", \%taxonomy_colours );

                # reinstate end tag
                print $svg_out "\<\/svg\>";
            }
            else {
                print $svg_out "$line";
            }
            $colour = "black";
        }
    }
}

sub draw_key {
    my ( $svg_out, $width, $height, $taxonomy_colours ) = @_;

    my $x1 = 25;    #$height / 2; #"25";
    my $x2 = 55;    #$x1 + 30;    #"55";

    my $taxa_number = keys %{$taxonomy_colours};

    print "Y: $width - $height - $taxa_number\n";

    my $y1 = $height / 2;

    #$y1 = ( $height - ( 80 * $taxa_number ) );
    my $y2 = $y1 + 10;
    my $y3 = $y1 - 20;

    print $svg_out "
    <g id=\"key\">
      <text
         x=\"$x1\"
         y=\"$y3\"
         id=\"key\"
         xml:space=\"preserve\"
         style=\"font-size:14px;font-style:normal;font-weight:normal;fill:#000000;fill-opacity:1;stroke:none;font-family:OpenSymbol\">Key
         </text>";

    for my $key ( sort keys %taxonomy_colours ) {

        my $colour = $taxonomy_colours{$key};

        print $svg_out "
            <g
                id=\"$key\">
            <rect
                width=\"25\"
                height=\"10\"
                x=\"$x1\"
                y=\"$y1\"
                id=\"rect_$key\"
                style=\"opacity:1;fill:$colour;fill-opacity:1;stroke:none\" />\n";
        print $svg_out "
            <text
                x=\"$x2\"
                y=\"$y2\"
                id=\"text_$key\"
                xml:space=\"preserve\"
                style=\"font-size:12px;font-style:normal;font-weight:normal;fill:$colour;fill-opacity:1;stroke:none;font-family:OpenSymbol\">$key
                </text></g>\n";
        $y1 += 10;
        $y2 += 10;
    }
    print $svg_out "</g>\n";
}

#
# Trees
#
sub draw_eps_tree {
    my $renamed         = shift;
    my $trees_directory = "$outdir\/trees\/$renamed";
    my $trees_dir_out   = "$trees_directory\/eps";
    make_path("$trees_dir_out");

    my @trees_to_svg = glob "$trees_directory\/*.treefile";

    for my $i ( 0 .. $#trees_to_svg ) {
        my $current_file = $trees_to_svg[$i];

        print
            "[orchard_accessories:INFO] - Drawing EPS $renamed Tree from $current_file\n";

        my $basename = fileparse( $current_file, qr/\Q.treefile\E/ );

        my $tree_input = Bio::TreeIO->new(
            -file   => "$current_file",
            -format => 'newick'
        );

        if ( my $tree = $tree_input->next_tree ) {
            my $tree_output = Bio::Tree::Draw::Cladogram->new(
                -bootstrap => 1,
                -tree      => $tree,
                -compact   => 0
            );
            $tree_output->print( -file => "$trees_dir_out\/$basename.eps" );
        }
    }
}

sub draw_dendroscope_tree {
    my ( $renamed, $type ) = @_;
    my $trees_directory = "$outdir\/trees\/$renamed";

    my $trees_dir_out = "$trees_directory\/$type";
    make_path("$trees_dir_out");

    my @trees_to_svg = glob "$trees_directory\/*.treefile";

    if ( $#trees_to_svg <= 0 ) {
        print
            "[orchard_accessories:ERR] - Missing renamed trees, did you forget the -n option?\n";
        exit 0;
    }

    for my $i ( 0 .. $#trees_to_svg ) {
        my $current_file = $trees_to_svg[$i];

        print
            "[orchard_accessories:INFO] - Drawing $type $renamed Tree from $current_file\n";

        my $basename = fileparse( $current_file, qr/\Q.treefile\E/ );

        $basename =~ m/(.*)(_hits_aligned_masked_)(FT|IQ)/i;
        my $accession = $1;

        my $dendroscope_opts = "open file=$current_file\;\n";
        $dendroscope_opts
            .= "set drawer=RectangularPhylogram\;\nladderize=left\;\n";
        $dendroscope_opts .= "zoom what=expand\;\nset sparselabels=false\;\n";
        $dendroscope_opts
            .= "select nodes=labeled\;\nset labelcolor=255 0 0\;\n";
        $dendroscope_opts
            .= "deselect all\;\nselect nodes=leaves\;\nset labelcolor=0 0 0\;\ndeselect all\;\n";
        $dendroscope_opts
            .= "find searchtext=$accession\;\nset labelfillcolor=255 0 0\;\ndeselect all\;\n";
        $dendroscope_opts
            .= "exportimage file=$trees_dir_out\/$basename\.$type format=$type replace=true\;\n";
        $dendroscope_opts .= "quit\;\n";

        open my $command_file, '>', "$outdir\/dendroscope.cmd";
        print {$command_file} $dendroscope_opts;
        close $command_file;

        my $dendroscope_command
            = "xvfb-run --auto-servernum --server-num=1 Dendroscope -g true -c $outdir\/dendroscope.cmd 1>/dev/null";
        system($dendroscope_command);

        unlink "$outdir\/dendroscope.cmd";

        if ( $type eq 'svg' ) {
            my $tidy_obj = XML::Tidy->new(
                'filename' => "$trees_dir_out\/$basename\.$type" );
            $tidy_obj->tidy();
            $tidy_obj->write();
        }
    }
}

#
# Renaming
#
sub rename_sequences {
    my $stage             = shift;
    my $directory         = "$outdir\/$stage";
    my $renamed_directory = "$directory\/renamed";
    make_path($renamed_directory);

    my $dbh = sqllite();

    my @files_to_rename = glob "$directory\/*.fasta";

    for my $i ( 0 .. $#files_to_rename ) {
        my $current_file = $files_to_rename[$i];
        print
            "[orchard_accessories:INFO] - Renaming Taxa in Sequence File $current_file\n";

        my $input_file = new Bio::SeqIO(
            -file   => "$current_file",
            -format => "fasta"
        );

        my $basename = fileparse( $current_file, qr/\Q.fasta\E/ );
        my $output_file = new Bio::SeqIO(
            -file   => ">$renamed_directory\/$basename\_renamed\.fasta",
            -format => "fasta"
        );

        while ( my $seq = $input_file->next_seq ) {

            my $current_seq = $seq->id;

            my $statement
                = qq(SELECT odb_accessions.extracted_accession, odb_maintable.genus_species, odb_maintable.source FROM odb_maintable INNER JOIN odb_accessions ON odb_maintable.genome_id = odb_accessions.lookup_id WHERE hashed_accession='$current_seq');
            my $prepare = $dbh->prepare($statement);
            $prepare->execute();

            my ( $extracted_accession, $genus_species, $source )
                = $prepare->fetchrow_array();

            if ( defined $genus_species ) {
                $genus_species =~ s/ /\_/g;

                $seq->id("$genus_species\_\[$source\-$extracted_accession\]");
            }

            $output_file->write_seq($seq);
        }
    }
}

sub rename_newick_trees {
    my $trees_directory         = "$outdir\/trees";
    my $trees_renamed_directory = "$outdir\/trees\/renamed";
    make_path($trees_renamed_directory);

    my $dbh = sqllite();

    my @trees_to_rename = glob "$trees_directory\/*.treefile";

    for my $i ( 0 .. $#trees_to_rename ) {
        my $current_file = $trees_to_rename[$i];
        print
            "[orchard_accessories:INFO] - Renaming Taxa in Tree $current_file\n";

        my $input_tree = new Bio::TreeIO(
            -file   => "$current_file",
            -format => "newick"
        );

        my $basename = fileparse( $current_file, qr/\Q.treefile\E/ );
        my $output_tree = new Bio::TreeIO(
            -file =>
                ">$trees_renamed_directory\/$basename\_renamed\.treefile",
            -format => "newick"
        );

        while ( my $tree = $input_tree->next_tree ) {
            my $rootnode = $tree->get_root_node;

            foreach my $node ( $rootnode->get_all_Descendents() ) {
                if ( $node->is_Leaf ) {
                    my $current_node = $node->id;

                    my $statement
                        = qq(SELECT odb_accessions.extracted_accession, odb_maintable.genus_species, odb_maintable.source FROM odb_maintable INNER JOIN odb_accessions ON odb_maintable.genome_id = odb_accessions.lookup_id WHERE hashed_accession='$current_node');
                    my $prepare = $dbh->prepare($statement);
                    $prepare->execute();

                    my ( $extracted_accession, $genus_species, $source )
                        = $prepare->fetchrow_array();

                    if ( defined $genus_species ) {
                        $node->id(
                            "$genus_species \[$source\-$extracted_accession\]"
                        );
                    }
                }
            }

            $output_tree->write_tree($tree);
        }
    }
}

#
# SQLLite
#
sub sqllite {
    my $db_name  = fileparse $orchardDB_location;
    my $driver   = 'SQLite';
    my $database = "$orchardDB_location\/$db_name\.sqlite";
    my $dsn      = "DBI:$driver:dbname=$database";

    my $dbh
        = DBI->connect( $dsn, $orchardDB_username, $orchardDB_password,
        { RaiseError => 1 } )
        or die $DBI::errstr;

    return $dbh;
}

#
# Help Function
#
sub help_message {
    print "Usage: orchard_accessories -p params.yaml -n\n";
    print "Required Parameters\n";
    print "\t-p <parameters.yaml>\n";
    print "Optional Parameters\n";
    print "Renaming\n";
    print "\t-s\tRename Taxa in Sequence Hits Files\n";
    print "\t-a\tRename Taxa in Alignment Files\n";
    print "\t-m\tRename Taxa in Masked Files\n";
    print "\t-e\tRename Taxa in Excluded Files\n";
    print "\t-n\tRename Taxa in Newick Trees\n";
    print "Tree Drawing\n";
    print "\t-renamed\tConvert Renamed Trees use with below\n";
    print "\t-eps_tree\tDraw a Phylogram in EPS Format (Basic)\n";
    print "\t-svg_tree\tDraw a Phylogram with Dendroscope in SVG Format\n";
    print "\t-pdf_tree\tDraw a Phylogram with Dendroscope in PDF Format\n";
    print
        "Cite: https://github.com/guyleonard/orchard and doi: 10.1105/tpc.109.065805\n";
    exit(0);
}
